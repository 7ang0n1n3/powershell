<#
.SYNOPSIS
    Lightweight curl-like HTTP client in PowerShell.

.DESCRIPTION
    Sends HTTP requests and displays responses. Supports common curl options
    including custom headers, request bodies, authentication, redirects,
    file upload, cookies, and verbose output.

.PARAMETER Uri
    The URL to request (positional).

.PARAMETER Method
    HTTP method: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS. Alias: -X
    Defaults to GET, or POST when -Data/-Form is supplied.

.PARAMETER Header
    One or more request headers in "Name: Value" format. Alias: -H

.PARAMETER Data
    Request body string. Prefix with @ to read from a file (e.g. @body.json). Alias: -d

.PARAMETER Output
    Write response body to a file instead of stdout. Alias: -o

.PARAMETER Location
    Follow HTTP redirects (up to 20). Alias: -L

.PARAMETER TraceMode
    Verbose mode — print request and response headers. Alias: -v

.PARAMETER Silent
    Suppress all informational/diagnostic output. Alias: -s

.PARAMETER Include
    Include response status line and headers in output. Alias: -i

.PARAMETER Head
    Send a HEAD request; show only response headers.

.PARAMETER User
    Basic auth credentials as "user:password". Prompts for password if
    only "user" is provided. Alias: -u

.PARAMETER UserAgent
    Override the User-Agent header. Alias: -A

.PARAMETER MaxTime
    Maximum seconds for the entire request. Default: 30.

.PARAMETER Insecure
    Skip TLS/SSL certificate validation. Alias: -k

.PARAMETER Form
    Multipart form fields. Use "key=value" for text or "key=@file" for
    file upload. May be specified multiple times. Alias: -F

.PARAMETER Cookie
    Cookies to send: "name=value; name2=value2" or path to a Netscape
    cookie jar file. Alias: -b

.PARAMETER CookieJar
    Write response Set-Cookie headers to a Netscape-format cookie jar
    file. Alias: -c

.PARAMETER ContentType
    Explicitly set the Content-Type header for the request body.

.PARAMETER Compressed
    Add Accept-Encoding: gzip, deflate and decompress the response.

.EXAMPLE
    .\curl.ps1 https://httpbin.org/get

    .\curl.ps1 -X POST https://httpbin.org/post `
               -H 'Content-Type: application/json' `
               -d '{"user":"alice"}'

    .\curl.ps1 -u alice https://api.example.com/secure

    .\curl.ps1 -L -o page.html https://example.com

    .\curl.ps1 -F name=Alice -F avatar=@photo.jpg https://example.com/upload

    .\curl.ps1 -v -i https://httpbin.org/get
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory, Position = 0)]
    [string]$Uri,

    [Alias('X')]
    [string]$Method,

    [Alias('H')]
    [string[]]$Header,

    [Alias('d')]
    [string]$Data,

    [Alias('o')]
    [string]$Output,

    [Alias('L')]
    [switch]$Location,

    [Alias('v')]
    [switch]$TraceMode,

    [Alias('s')]
    [switch]$Silent,

    [Alias('i')]
    [switch]$Include,

    [switch]$Head,

    [Alias('u')]
    [string]$User,

    [Alias('A')]
    [string]$UserAgent = 'curl/8.11.0',

    [int]$MaxTime = 30,

    [Alias('k')]
    [switch]$Insecure,

    [Alias('F')]
    [string[]]$Form,

    [Alias('b')]
    [string]$Cookie,

    [Alias('c')]
    [string]$CookieJar,

    [string]$ContentType,

    [switch]$Compressed
)

$ErrorActionPreference = 'Stop'

# ── Output helpers ────────────────────────────────────────────────────────────

# Diagnostic output → host (not captured by pipeline)
function Write-Diag {
    param([string]$Msg, [ConsoleColor]$Color = [ConsoleColor]::DarkGray)
    if (-not $Silent) { Write-Host $Msg -ForegroundColor $Color }
}

# Data output → stdout (captured by pipeline / redirection)
function Write-Stdout {
    param([string]$Text)
    [Console]::Write($Text)
}

function Format-Bytes {
    param([long]$N)
    if ($N -lt 1KB) { "${N} B" }
    elseif ($N -lt 1MB) { '{0:N1} KB' -f ($N / 1KB) }
    else { '{0:N1} MB' -f ($N / 1MB) }
}

# ── Cookie helpers ────────────────────────────────────────────────────────────

function Read-CookieJar {
    param([string]$Spec)
    if (Test-Path $Spec -ErrorAction SilentlyContinue) {
        $pairs = Get-Content $Spec | Where-Object {
            $_ -notmatch '^\s*#' -and $_.Trim() -ne ''
        } | ForEach-Object {
            $cols = $_ -split '\t'
            if ($cols.Count -ge 7) { "$($cols[5])=$($cols[6])" }
        } | Where-Object { $_ }
        return $pairs -join '; '
    }
    return $Spec   # treat as literal "name=value; ..." string
}

function Write-CookieJar {
    param([System.Net.Http.HttpResponseMessage]$Resp, [string]$Path)
    $setCookieHeader = $Resp.Headers | Where-Object { $_.Key -ieq 'Set-Cookie' }
    if (-not $setCookieHeader) { return }

    $lines = @(
        '# Netscape HTTP Cookie File'
        '# Generated by curl.ps1'
        ''
    )

    $reqHost = ([Uri]$Uri).Host

    foreach ($rawCookie in $setCookieHeader.Value) {
        $parts    = $rawCookie -split ';\s*'
        $nameVal  = $parts[0] -split '=', 2
        if ($nameVal.Count -lt 2) { continue }

        $domain  = $reqHost
        $path    = '/'
        $secure  = 'FALSE'
        $expires = '0'

        foreach ($attr in $parts[1..($parts.Count - 1)]) {
            $kv = $attr -split '=', 2
            switch ($kv[0].Trim().ToLower()) {
                'domain'  { if ($kv.Count -gt 1) { $domain  = $kv[1].Trim() } }
                'path'    { if ($kv.Count -gt 1) { $path    = $kv[1].Trim() } }
                'secure'  { $secure = 'TRUE' }
                'expires' {
                    if ($kv.Count -gt 1) {
                        try {
                            $expires = [DateTimeOffset]::Parse($kv[1].Trim()).ToUnixTimeSeconds()
                        } catch {}
                    }
                }
            }
        }

        $tail   = if ($domain.StartsWith('.')) { 'TRUE' } else { 'FALSE' }
        $lines += "$domain`t$tail`t$path`t$secure`t$expires`t$($nameVal[0].Trim())`t$($nameVal[1].Trim())"
    }

    $lines | Set-Content -Path $Path -Encoding UTF8
    Write-Diag "Cookies saved to $Path"
}

# ── Resolve effective HTTP method ─────────────────────────────────────────────
if ($Head) {
    $Method = 'HEAD'
} elseif (-not $Method) {
    $Method = if ($Data -or $Form) { 'POST' } else { 'GET' }
}
$Method = $Method.ToUpper()

# ── Build HttpClientHandler ───────────────────────────────────────────────────
$handler = [System.Net.Http.HttpClientHandler]::new()
$handler.AllowAutoRedirect        = $Location.IsPresent
$handler.MaxAutomaticRedirections = 20
$handler.AutomaticDecompression   =
    if ($Compressed) {
        [System.Net.DecompressionMethods]::GZip -bor [System.Net.DecompressionMethods]::Deflate
    } else {
        [System.Net.DecompressionMethods]::None
    }

if ($Insecure) {
    $handler.ServerCertificateCustomValidationCallback = { $true }
}

$httpClient         = [System.Net.Http.HttpClient]::new($handler)
$httpClient.Timeout = [TimeSpan]::FromSeconds($MaxTime)

# ── Build HttpRequestMessage ──────────────────────────────────────────────────
$request = [System.Net.Http.HttpRequestMessage]::new(
    [System.Net.Http.HttpMethod]::new($Method),
    $Uri
)

$request.Headers.TryAddWithoutValidation('User-Agent', $UserAgent) | Out-Null

if ($Compressed) {
    $request.Headers.TryAddWithoutValidation('Accept-Encoding', 'gzip, deflate') | Out-Null
}

# Basic auth
if ($User) {
    $creds = $User
    if ($creds -notmatch ':') {
        $ss    = Read-Host "Enter password for '$creds'" -AsSecureString
        $plain = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
                     [Runtime.InteropServices.Marshal]::SecureStringToBSTR($ss))
        $creds = "${creds}:${plain}"
    }
    $b64 = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($creds))
    $request.Headers.TryAddWithoutValidation('Authorization', "Basic $b64") | Out-Null
}

# Cookies
if ($Cookie) {
    $request.Headers.TryAddWithoutValidation('Cookie', (Read-CookieJar $Cookie)) | Out-Null
}

# Custom headers
foreach ($h in $Header) {
    $sep = $h.IndexOf(':')
    if ($sep -lt 1) { Write-Warning "Skipping malformed header: $h"; continue }
    $n = $h.Substring(0, $sep).Trim()
    $v = $h.Substring($sep + 1).Trim()
    $request.Headers.TryAddWithoutValidation($n, $v) | Out-Null
}

# ── Request body ──────────────────────────────────────────────────────────────
if ($Form) {
    $mp = [System.Net.Http.MultipartFormDataContent]::new()
    foreach ($field in $Form) {
        $eq = $field.IndexOf('=')
        if ($eq -lt 1) { Write-Warning "Skipping malformed form field: $field"; continue }
        $fname = $field.Substring(0, $eq)
        $fval  = $field.Substring($eq + 1)

        if ($fval.StartsWith('@')) {
            $fp = $fval.Substring(1)
            if (-not (Test-Path $fp)) { Write-Error "Form file not found: $fp"; exit 1 }
            $bytes    = [IO.File]::ReadAllBytes($fp)
            $fc       = [System.Net.Http.ByteArrayContent]::new($bytes)
            $mp.Add($fc, $fname, [IO.Path]::GetFileName($fp))
        } else {
            $mp.Add([System.Net.Http.StringContent]::new($fval), $fname)
        }
    }
    $request.Content = $mp

} elseif ($Data) {
    $bodyBytes =
        if ($Data.StartsWith('@')) {
            $fp = $Data.Substring(1)
            if (-not (Test-Path $fp)) { Write-Error "Data file not found: $fp"; exit 1 }
            [IO.File]::ReadAllBytes($fp)
        } else {
            [Text.Encoding]::UTF8.GetBytes($Data)
        }

    $request.Content = [System.Net.Http.ByteArrayContent]::new($bodyBytes)

    $ct =
        if     ($ContentType)              { $ContentType }
        elseif ($Data -match '^\s*[\[{]') { 'application/json' }
        else                               { 'application/x-www-form-urlencoded' }

    $request.Content.Headers.TryAddWithoutValidation('Content-Type', $ct) | Out-Null
}

# ── Print request headers (verbose) ──────────────────────────────────────────
if ($TraceMode) {
    Write-Diag ''
    Write-Diag "> $Method $Uri" -Color Cyan
    foreach ($h in $request.Headers) {
        Write-Diag "> $($h.Key): $($h.Value -join ', ')"
    }
    if ($request.Content) {
        foreach ($h in $request.Content.Headers) {
            Write-Diag "> $($h.Key): $($h.Value -join ', ')"
        }
    }
    Write-Diag '>'
    Write-Diag ''
}

# ── Send request ──────────────────────────────────────────────────────────────
try {
    $response = $httpClient.SendAsync(
        $request,
        [System.Net.Http.HttpCompletionOption]::ResponseHeadersRead
    ).GetAwaiter().GetResult()
} catch [System.Threading.Tasks.TaskCanceledException] {
    Write-Error "Request timed out after ${MaxTime}s."
    exit 1
} catch {
    Write-Error "Request failed: $_"
    exit 1
}

$statusCode = [int]$response.StatusCode
$statusText = $response.ReasonPhrase

# ── Print response headers ────────────────────────────────────────────────────
$showRespHeaders = $TraceMode -or $Include -or $Head

if ($showRespHeaders) {
    $statusColor =
        if    ($statusCode -lt 300) { [ConsoleColor]::Green }
        elseif($statusCode -lt 400) { [ConsoleColor]::Yellow }
        else                        { [ConsoleColor]::Red }

    # Decide whether to print to stdout (Include/Head) or host (TraceMode only)
    $printHeader = {
        param([string]$Line, [ConsoleColor]$Col = [ConsoleColor]::DarkGray)
        if ($Include -or $Head) { Write-Stdout ($Line + "`r`n") }
        else { Write-Diag $Line -Color $Col }
    }

    & $printHeader "HTTP/$($response.Version) $statusCode $statusText" $statusColor
    foreach ($h in $response.Headers) {
        & $printHeader "$($h.Key): $($h.Value -join ', ')"
    }
    foreach ($h in $response.Content.Headers) {
        & $printHeader "$($h.Key): $($h.Value -join ', ')"
    }
    & $printHeader ''
}

# ── Save cookies ──────────────────────────────────────────────────────────────
if ($CookieJar) {
    Write-CookieJar -Resp $response -Path $CookieJar
}

# ── Read and emit body ────────────────────────────────────────────────────────
if ($Method -ne 'HEAD') {
    $bodyStream = $response.Content.ReadAsStreamAsync().GetAwaiter().GetResult()

    try {
        if ($Output) {
            $outStream = [IO.File]::Create($Output)
            try     { $bodyStream.CopyTo($outStream) }
            finally { $outStream.Dispose() }
            Write-Diag "Saved $(Format-Bytes (Get-Item $Output).Length) → $Output" -Color Green
        } else {
            # Detect charset from Content-Type header
            $enc = [Text.Encoding]::UTF8
            $ct  = "$($response.Content.Headers.ContentType)"
            if ($ct -match 'charset=([^\s;]+)') {
                try { $enc = [Text.Encoding]::GetEncoding($Matches[1]) } catch {}
            }

            $reader = [IO.StreamReader]::new($bodyStream, $enc)
            try     { Write-Stdout ($reader.ReadToEnd()) }
            finally { $reader.Dispose() }
        }
    } finally {
        $bodyStream.Dispose()
    }
}

$response.Dispose()
$httpClient.Dispose()

# ── Exit code mirrors curl: non-2xx → 1 ──────────────────────────────────────
exit ([int]($statusCode -ge 400))
